#!/usr/bin/env python

"""Controls transmission daemon to save user from routine operations."""

import errno
import getopt
import json
import logging
import os
import re
import shutil
import subprocess
import sys
import tempfile
import time

import pymongo

import transmissionrpc.client

import pycl.daemon
import pycl.log
import pycl.misc

from pycl import constants
from pycl.core import Error, LogicalError

LOG = logging.getLogger("transmission-controller")


def check_free_space(download_dir):
    """Checks whether we have enough free space on the disk."""

    if SETTINGS.get("free-space-threshold", -1) < 0:
        return True

    # df gives a different output for "dir" and "dir/"
    download_dir += "/"

    process = subprocess.Popen([ "df", download_dir ],
        stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    stdout, stderr = process.communicate()

    if process.returncode:
        raise Error("df returned an error for {0}: {1}.",
            download_dir, stderr.replace("\n", " ").strip())

    stat = re.sub(r" +", " ", stdout.split("\n")[1]).split(" ")
    device = stat[0]
    usage = stat[4]
    free_space = 100 - int(re.match(r"^(\d+)%$", usage).group(1))

    if free_space <= SETTINGS["free-space-threshold"]:
        LOG.info("We don't have enough free space on %s: %s%% vs %s%%.",
            device, free_space, SETTINGS["free-space-threshold"])
        return False
    else:
        return True


def cleanup_fs(torrents):
    """Removes seeding torrents if free space on the disk is too small."""

    try:
        download_dir = os.path.normpath(SETTINGS["download-dir"])

        torrents = sorted(
            ( torrent for torrent in torrents if os.path.normpath(torrent.downloadDir) == download_dir ),
            cmp = lambda a, b: cmp(a.doneDate, b.doneDate))

        if torrents and not check_free_space(download_dir):
            for torrent in torrents:
                LOG.info("Removing torrent %s to get a free space on the disk...", torrent.name)
                remove_torrent(torrent)

                if check_free_space(download_dir):
                    break
    except Exception as e:
        LOG.error("Failed to cleanup the filesystem: %s", e)


def control_transmission(action = None):
    """Controls the Transmission."""

    torrents = TRANSMISSION.info().values()
    remove_old_db_torrents(torrents)

    removable_torrents = []

    for torrent in torrents:
        status = torrent.status
        LOG.debug("Checking torrent %s (%s)...", torrent.name, status)

        if action == "start" and status == "stopped":
            LOG.info("Starting torrent %s...", torrent.name)
            TRANSMISSION.start(torrent.hashString)
            status = "seeding" if torrent.doneDate else "downloading"
        elif action == "stop" and status != "stopped":
            LOG.info("Stopping torrent %s...", torrent.name)
            TRANSMISSION.stop(torrent.hashString)
            status = "stopped"

        if SETTINGS.get("max-announce-interval", 0) > 0 and status != "stopped":
            last_announce = 0
            for tracker_stats in torrent.trackerStats:
                if tracker_stats["lastAnnounceTime"] > last_announce:
                    last_announce = tracker_stats["lastAnnounceTime"]

            if time.time() >= last_announce + SETTINGS["max-announce-interval"] * constants.MINUTE_SECONDS:
                # Notice: doesn't work without patching transmission if tracker
                # sends its own min announce interval
                LOG.debug("Reannouncing torrent %s...", torrent.name)
                TRANSMISSION.reannounce(torrent.hashString)

        if torrent.doneDate:
            torrent_downloaded(torrent)

            if (
                SETTINGS.get("max-seed-time", -1) >= 0 and
                time.time() - torrent.doneDate >= SETTINGS["max-seed-time"]
            ):
                LOG.info("Torrent %s has seeded enough time to delete it. Deleting it...", torrent.name)
                remove_torrent(torrent)
            else:
                removable_torrents.append(torrent)

    cleanup_fs(removable_torrents)


def copy_torrent(torrent, destination):
    """Copies the specified torrent to the "copy to" dir."""

    LOG.info("Copying torrent %s:", torrent.name)

    for torrent_file in torrent.files().itervalues():
        if not torrent_file["selected"]:
            continue

        path = os.path.normpath(torrent_file["name"]).strip("/")
        LOG.debug("Copying file %s...", path)

        try:
            os.makedirs(os.path.join(destination, os.path.dirname(path)), 0750)
        except EnvironmentError as e:
            if e.errno != errno.EEXIST:
                raise e

        fd = os.open(os.path.join(destination, path),
            os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0640)

        try:
            shutil.copyfile(
                os.path.join(torrent.downloadDir, path),
                os.path.join(destination, path))
        finally:
            os.close(fd)


def db():
    """Returns the database connection."""

    return pymongo.Connection()["transmission-controller"]


def get_db_torrent(torrent):
    """Returns torrent info from the database."""

    uuid = get_torrent_uuid(torrent)

    torrent_info = torrent_coll().find_one({ "_id": uuid })

    if torrent_info is None:
        torrent_info = {
            "_id":    uuid,
            "name":   torrent.name,
            "copied": False,
        }

    return torrent_info


def get_torrent_uuid(torrent):
    """Returns UUID of the specified torrent."""

    return "{0}:{1}".format(torrent.hashString, torrent.addedDate)


def main():
    """The script's main function."""

    # Parsing command line arguments -->
    cron_mode = False
    debug_mode = False
    action = None

    cmd_options, args = getopt.gnu_getopt(
        sys.argv[1:], "", [
            "cron",
            "debug",
            "start-all",
            "stop-all",
        ])

    for option, value in cmd_options[:]:
        if option == "--cron":
            cron_mode = True
        elif option == "--debug":
            debug_mode = True
        elif option == "--start-all":
            action = "start"
        elif option == "--stop-all":
            action = "stop"
        else:
            raise LogicalError()
    # Parsing command line arguments <--


    if debug_mode:
        pycl.log.setup(debug_mode = True)
    else:
        pycl.log.setup(level = logging.ERROR if cron_mode else None)


    pid_file = "/var/run/lock/transmission-controller"

    try:
        pid_file_fd = pycl.daemon.acquire_pidfile(pid_file)
    except pycl.daemon.PidFileLocked as e:
        if cron_mode:
            LOG.debug("Exiting: %s", e)
        else:
            raise
    else:
        try:
            global SETTINGS
            with open(os.path.expanduser("~/.config/transmission-daemon/settings.json"), "r") as config:
                SETTINGS = json.load(config)

            global TRANSMISSION
            TRANSMISSION = transmissionrpc.client.Client(
                user = SETTINGS["rpc-username"], password = SETTINGS["rpc-plain-password"],
                timeout = constants.MINUTE_SECONDS)

            control_transmission(action)
        finally:
            pycl.misc.syscall_wrapper(os.close, pid_file_fd)
            pycl.misc.syscall_wrapper(os.unlink, pid_file)


def remove_old_db_torrents(torrents):
    """Removes all unexisting torrents from the database."""

    torrent_coll().remove(
        { "_id": { "$nin": [ get_torrent_uuid(torrent) for torrent in torrents ] } }, safe = True)


def remove_torrent(torrent):
    """Removes the specified torrent."""

    TRANSMISSION.remove(torrent.hashString, delete_data = True)


def save_db_torrent(db_torrent):
    """Saves the torrent info to the database."""

    torrent_coll().save(db_torrent, safe = True)


def torrent_coll():
    """Returns collection with torrent info."""

    return db()["torrents"]


def torrent_downloaded(torrent):
    """Called when torrent finished downloading."""

    db_torrent = get_db_torrent(torrent)
    if db_torrent["copied"]:
        return

    copy_to = SETTINGS.get("copy-to-dir")

    if SETTINGS.get("copy-tv-shows-to-dir"):
        # Check whether this is a TV show
        match = re.match(r"(.+)[._](?:s\d+e\d+|\d+x\d+)[._]", file_name, re.IGNORECASE)

        if match is not None:
            # Get the TV show name from the different file naming formats
            tv_show_name = match.group(1).replace(".", " ").replace("_", " ").strip().title()
            tv_show_name = re.sub(r"\s+", " ", tv_show_name)

            # Some releasers add year to the file name
            match = re.match(r"(.+) \d+", tv_show_name)
            if match is not None:
                tv_show_name = match.group(1)

            if tv_show_name in ( name.strip() for name in SETTINGS.get("copy-tv-shows", "").split(",") if name.strip() ):
                copy_to = os.path.join(SETTINGS["copy-tv-shows-to-dir"], tv_show_name)

                try:
                    os.mkdir(copy_to, 0750)
                except EnvironmentError as e:
                    if e.errno != errno.EEXIST:
                        raise e

    if copy_to:
        copy_torrent(torrent, copy_to)
        db_torrent["copied"] = True
        save_db_torrent(db_torrent)


if __name__ == "__main__":
    main()
